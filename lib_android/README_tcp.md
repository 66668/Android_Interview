# TCP/IP 总结
参考 https://blog.csdn.net/qq_38950316/article/details/81087809

## 名词解释
1. ACK  TCP报头的控制位之一,对数据进行确认.确认由目的端发出,用它来告诉发送端这个序列号之前的数据段都收到了.比如,确认号为X,则表示前X-1个数据段都收到了,只有当ACK=1时,确认号才有效,当ACK=0时,确认号无效,这时会要求重传数据,保证数据的完整性.
2.  SYN  同步序列号（Synchronize Sequence Numbers）,TCP建立连接时将这个位置1
3.  FIN  发送端完成发送任务位,当TCP完成数据传输需要断开时,提出断开连接的一方将这位置1    
4. 序列号seq：占4个字节，编号由本地随机产生，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。
5. 确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。
6. 确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效
7. 同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。
8. 终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接
9. MSL：报文最大生存时间

ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。


## TCP数据包的包头结构

1. 源端口 16位+目标端口 16位(32)
2. 序列号 32位
4. 确认号 32位
5. 数据偏移 4位 +保留 6位 + 控制代码（RUG/ACK/PSH/RST/SYN/FIN）6位 +窗口大小 16位
6. 校验 16位 +紧急指针 16位 （1--6固定大小20哥字节）
7. 选项  32位(可选)
8. 数据...
 
 ![流程图](https://github.com/66668/Android_Interview/blob/master/pictures/tcp_net_01.jpg)
 
 ![流程图](https://github.com/66668/Android_Interview/blob/master/pictures/tcp_net_02.png)

## TCP/IP 参考模型/4层模型

链路层(比特)-->网络层（数据帧）-->传输层（数据包）-->应用层（数据段）

## TCP/IP协议族

![tcp/ip协议族](https://github.com/66668/Android_Interview/blob/master/pictures/tcpip_01.jpg)

![tcp/ip协议族](https://github.com/66668/Android_Interview/blob/master/pictures/tcpip_02.jpg)

## TCP的通讯原理
1. socket套接字：tcp用主机的ip地址+主机的端口号作为tcp的端点，这种端点就是socket套接字。
2. tcp缓冲区：每个tcp的socket内核中，都有一个发送缓冲区和一个接收缓冲区
3. tcp的可靠性和高效性：特定时间内，缺失的数据包重发
4. tcp协议中的窗口机制：（滑动窗口）发送方和接收方都会维护一个数据帧序列，这个序列被称作窗口。发送方的窗口大小由接收方确认。
    窗口机制的目的：确保数据不丢失（丢失重发）；控制发送速度（避免接收方内存溢出，避免网络堵塞）；
    
## 三次握手

建立一个TCP连接时，需要客户端和服务端总共分发送三个包确认连接的建立。

1. 第一次握手：建立连接时，客户端发送数据包（SYN=1，seq=j（随机的））到服务器，等待服务端的确认（服务端状态：CLOSED-->SYN_SENT；
2. 第二次握手：服务器收到数据包，先确认客户的数据包（收到客户端的seq=j后，服务端才可以设置ack=j+1），同时自己也发送一个数据包（SYN=1（该值是第一次握手客户端修改的值）,ACK=1（该值是本次握手修改的值）,ack=j+1,seq=k）(服务器状态:SYN_SENT-->SYN_RECV)；
3. 第三次握手：客户端收到数据包，向服务器发送确认包(ACK=1,ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。


 ![流程图](https://github.com/66668/Android_Interview/blob/master/pictures/tcp_net_03.png)

## 四次挥手

关闭一个TCP连接时，需要客户端和服务端总共分发送4个包确认

1. 客户端发送一个FIN数据包到服务端（FIN=1,seq=u），关闭客户端向服务器数据传送；(但是服务端还是可以向客户端发送数据,客户端状态 estab_lished-->FIN_wait)
2. 服务器响应客户端FIN请求，返回给客户端一个ACK数据包；（ACK=1 seq=v,ack=u+1,服务端状态：estab_lished-->close_wait)
3. 服务端发送关闭请求给客户端（FIN=1,ACK=1,ack=u+1,seq=x,服务端状态:close_wait-->last_ack）。
4. 客户端发回ACK报文确认，经过2MSL的time_wait时间状态才关闭（ACK=1,ack=x+1,客户端等待2MSL才close,服务端收到ack后：last_ack-->close）

 ![流程图](https://github.com/66668/Android_Interview/blob/master/pictures/tcp_net_04.png)


### 【问题】为什么TCP连接是三次握手?

三次握手才能完整的交换tcp通信的初始序列号（SYN,ACK的序列号值保证统一），两次无法完全确认两端的序列号，而四次有些多余，是为了保证通信的可靠性（全双工通讯）。

### 为什么是四次握手？

答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。
但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。
**只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送**。故需要四步握手。

### 【问题】为什么客户端TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？
答1：
设置2MSL的目的是为了处理，网络异常下，服务端没收到客户端的ACk=1，服务端在MSL时间后，重传最后一个FIN包给客户端，客户端重新发送ACK，一来一回，两个包的最长时间就是2MSL。

### 【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，
时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，
服务器就认为客户端出了故障，接着就关闭连接。


##TCP与UDP区别（面试重点）

回答1：
1. TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接；
2. TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付；
3. TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的；UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）；
4. 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信；
5. TCP首部开销20字节;UDP的首部开销小，只有8个字节；
6. TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道，整体来看UDP开销较小。

回答2：

    TCP的优点： 可靠，稳定 TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，
        在数据传完后，还会断开连接用来节约系统资源。
        
    TCP的缺点： 慢，效率低，占用系统资源高，易被攻击 TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，
        确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 
        而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击
        
    UDP的优点： 快，比TCP稍安全 UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。
        没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击……
        
    UDP的缺点： 不可靠，不稳定 因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。
    
    基于上面的优缺点，各自应用场景：
    
        什么时候应该使用TCP： 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，
            比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输 …………
            
        什么时候应该使用UDP： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。
            比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TFTP ……

### 短连接 
连接->传输数据->关闭连接 
HTTP是无状态的，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。 
也可以这样说：短连接是指SOCKET连接后发送后接收完数据后马上断开连接。 
  
### 长连接 
连接->传输数据->保持连接 -> 传输数据-> 。。。 ->关闭连接。 
长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。 
  
### http的长连接 

HTTP也可以建立长连接的，使用Connection:keep-alive





 