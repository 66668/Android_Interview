#  序列化反序列化 总结

## Bundle传递数据为什么需要序列化? 

序列化，表示将一个对象转换成可存储或可传输的状态。序列化的原因基本三种情况:

1.永久性保存对象，保存对象的字节序列到本地文件中; 
2.对象在网络中传递;
3.对象在IPC间传递。

## 序列化与反序列化

### 概念

序列化是指将Java对象转换为字节序列的过程

反序列化则是将字节序列转换为Java对象的过程。

Java对象序列化是将实现了Serializable接口的对象转换成一个字节序列，能够通过网络传输、文件存储等方式传输 ，传输过程中却不必担心数据在不同机器、不同环境下发生改变，也不必关心字节的顺序或其他任何细节，并能够在以后将这个字节序列完全恢复为原来的对象(恢复这一过程称之为反序列化)。

对象的序列化是非常有趣的，因为利用它可以实现轻量级持久性，“持久性”意味着一个对象的生存周期不单单取决于程序是否正在运行，它可以生存于程序的调用之间。通过将一个序列化对象写入磁盘，然后在重新调用程序时恢复该对象，从而达到实现对象的持久性的效果。

本质上讲，序列化就是把实体对象状态按照一定的格式写入到有序字节流，反序列化就是从有序字节流重建对象，恢复对象状态。

### 为什么需要使用序列化和反序列化(场景)

因为bundle传递数据时只支持基本数据类型，所以在传递对象时需要序列化转换成可存储或可传输的本 质状态(字节流)。
序列化后的对象可以在网络、IPC(比如启动另一个进程的Activity、Service和 Reciver)之间进行传输，也可以存储到本地。

我们知道，不同进程/程序间进行远程通信时，可以相互发送各种类型的数据，包括文本、图片、音频、视频等，而这些数据都会以二进制序列的形式在网络上传送。

那么当两个Java进程进行通信时，能否实现进程间的对象传送呢？当然是可以的！如何做到呢？这就需要使用Java序列化与反序列化了。发送方需要把这个Java对象转换为字节序列，然后在网络上传输，接收方则需要将字节序列中恢复出Java对象。

我们清楚了为什么需要使用Java序列化和反序列化后，我们很自然地会想到Java序列化有哪些好处（场景）：

1. 实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（如：存储在文件里），实现永久保存对象。
2. 利用序列化实现远程通信，即：能够在网络上传输对象。
3. 内存中数据调用（Intent，下面会多次用到）。

### Java中下Serializable

 在使用 ObjectInputStream和ObjectOutputStream读写对象时，该对象的类必须实现序列化的。
 
### Android下Serializable

果对类成员属性进行了修改，那么再次读取这个对象时，会因为UID不同而抛出异常。
所以我们在实现Serializable接口同时，在类中要声明UID。

### Parcelable类

序列化方法和步骤

这是我们实现Parcelable接口的一系列方法。主要可以分为四步：

1. 创建私有化构造方法（或者protected）
2. 重写describeContents方法。
3. 重写writeToParcel方法，这个方法是我们将对象序列化的方法。
4. 实现Creator类，并实现createFromParcel方法和newArray方法，newArray方法不是很重要，主要看createFromParcel方法，这个方法是我们反序列化得到对象的方法

序列化后的对象全都存储在了这个里面。其实Parcelable类只是一个外壳，而真正实现了序列化的，是Parcel这个类，它里面有大量的方法，对各种数据进行序列化

## 有没有尝试简化Parcelable的使用?

使用Parcelable插件(Android Parcelable code generator)进行实体类的序列化的实现。

## Serializable和Parcelable总结
回答1：

1. 两者都是实现序列化得接口，都可以用Intent传递数据。
2. Serializable使用时会产生大量的临时变量，进行IO操作频繁，消耗比较大，但是实现方式简单。
3. Parcelable是Android提供轻量级方法，效率高，但是实现复杂。
4. 一般在内存中序列画传递时选用Parcelable。在设备或网络中传递选用Serializable。
5. 无论是Serializable还是Parcelable，两种内属性只要有对象，那么对应对象的类一定也要实现序列化。

回答2：

两者最大的区别在于 存储媒介的不同，**Serializable 使用I/O读写存储在硬盘上，而 Parcelable 是直接在内存中读写**。

很明显，内存的读写速度通常大于 IO 读写，所以在 Android 中传递数据优先选择 Parcelable。

Serializable 会使用反射，序列化和反序列化过程需要大量 I/O 操作， Parcelable 自已实现封送和解封 (marshalled &unmarshalled)操作不需要用反射，
数据也存放在 Native 内存中，效率要快很多。

![Serializable和Parcelable总结](https://github.com/66668/Android_Interview/blob/master/pictures/serialize_01.png)



